// data.json
{
  "token": "asasataaa",
  "supplier": "Projacs Academy"
}

// index.html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Security-Policy" content="">

    <title>Hello World! </title>

  </head>
  <body>
    <h1>Hello World!</h1>
    <p>Welcome to your Electron application.</p>
    <input type="text" name="token" id="token" placeholder="Enter your token">
    <input type="text" name="supplier" id="supplier" value="Projacs Academy" placeholder="Enter your supplier name">
    <button id="submit">Submit</button>
    <hr>
    <h2>Output</h2>
    <p id="output"></p>
    <ul id="results-list">
      
    </ul>

    <script type="module" src="/src/renderer.ts"></script>
  </body>
</html>


// package.json
{
  "name": "my-new-app",
  "productName": "my-new-app",
  "version": "1.0.0",
  "description": "My Electron application description",
  "main": ".vite/build/main.js",
  "scripts": {
    "start": "electron-forge start",
    "package": "electron-forge package",
    "make": "electron-forge make",
    "publish": "electron-forge publish",
    "lint": "eslint --ext .ts,.tsx ."
  },
  "devDependencies": {
    "@electron-forge/cli": "^7.4.0",
    "@electron-forge/maker-deb": "^7.4.0",
    "@electron-forge/maker-rpm": "^7.4.0",
    "@electron-forge/maker-squirrel": "^7.4.0",
    "@electron-forge/maker-zip": "^7.4.0",
    "@electron-forge/plugin-auto-unpack-natives": "^7.4.0",
    "@electron-forge/plugin-fuses": "^7.4.0",
    "@electron-forge/plugin-vite": "^7.4.0",
    "@electron-forge/shared-types": "^7.4.0",
    "@electron/fuses": "^1.8.0",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "electron": "30.0.2",
    "eslint": "^8.0.1",
    "eslint-plugin-import": "^2.25.0",
    "ts-node": "^10.0.0",
    "typescript": "~4.5.4",
    "vite": "^5.0.12"
  },
  "keywords": [],
  "author": {
    "name": "Mohannad Otaibi",
    "email": "mohannad.otaibi@gmail.com"
  },
  "license": "MIT",
  "dependencies": {
    "dotenv": "^16.4.5",
    "electron-squirrel-startup": "^1.0.0"
  }
}


// src/api/ariba.ts


const baseURL = 'https://s1.mn2.ariba.com/SM/rest';

const commonParams: paramsArray = {
    includeLegalAddress: true,
    categoryCode: [],
    regionCode: [],
    departmentCode: [],
    includeOrderingAddresses: true,
    includeRemittanceAddresses: true,
    purchasingUnitCodes: [],
    realmName: "JCD",
    smVendorIds: [],
    filterOutDisqualifiedMatrix: false,
    includeMatrix: false,
    searchQualificationAndRegistrationStatusAsAWhole: false,
    isErpIntegrated: null,
    keyword: "",
    qualificationStatus: [],
    preferredLevel: [],
    spqFilterAnswerRequests: [],
    certCondition: {},
    overallRiskScoreLevel: [],
    smProcessStatus: [],
    isFactory: false,
    activeType: "active",
    includeFacet: true,
    mainVendorsOnly: true,
    isBulkQualification: false,
    isMQEnhancementFlow: false,

};

const commonHeaders = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36',
    'X-Permitted-Cross-Domain-Policies': 'master-only',
    'sec-ch-ua': '"Not/A)Brand";v="99", "Google Chrome";v="115", "Chromium";v="115"',
    'sec-ch-ua-mobile': '?0',
    'sec-ch-ua-platform': '"Windows"',
};

const getSupplierParams = (customParams: any) =>{
    return { ...commonParams, ...customParams };
}

const refreshToken = async (token: string) =>{
    const url = `${baseURL}/internal/refreshtoken?realm=JCD`;

    const headers = {
        ...commonHeaders,
        'x-auth-token': token,
    };

    const response = await fetch(url, {
        method: 'GET',
        headers,
    });

    if (response.ok) {
        token = response.headers.get('x-auth-token');
        console.log('got new token', token)
    } else {
        console.error('Failed to refresh token');
    }
}

const makeRequest = async (endpoint: string, params: any, token: string) => {
    // Check if the data exists in the local JSON database
    const url = `${baseURL}/${endpoint}?realm=JCD`;

    const headers = {
        ...commonHeaders,
        'Content-Type': 'application/json',
        'x-auth-token': token,
    };

    refreshToken(token); // Refresh the token before making the request

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers,
            body: JSON.stringify(params),
        });

        if (!response.ok) {
            // if error code is 401 it means the token has expired
            if (response.status === 401) {
                console.log('Token expired, refreshing...');
                throw new Error('TokenExpired');
            }
            else {
                console.log(response);
                throw new Error(`Error in ${endpoint}: ${response.status} ${response.statusText}`);
            }
        }

        const data = await response.json();
        return data;
    } 
    catch (error) {
        console.error(`Error in ${endpoint}:`, error.message);
        throw error;
    }
}

export const searchSuppliers = async (customParams: any, token:string) => {
    const params = getSupplierParams({ ...customParams });
  
    return makeRequest('searchSuppliers', params, token);
}

// src/api/index.ts
export * from './ariba';

// src/index.css
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica,
    Arial, sans-serif;
  margin: auto;
  max-width: 38rem;
  padding: 2rem;
}


// src/main.ts
import  Storage  from './utilities/storage';
import { ipcMain, app, BrowserWindow } from 'electron';
import { searchSuppliers } from './api';
import path from 'path';
import * as dotenv from "dotenv";

const myStorage = new Storage('../../data.json');

dotenv.config();

console.log('main.ts');
console.log('env token', process.env.TOKEN)


ipcMain.on('save-inputs', async (event, data) => {
  try{
    await myStorage.save(data);
    console.log('data written', data) 
  }
  catch (error) {
    console.error('Failed to save inputs', error);
  }
  
});
ipcMain.on('load-inputs', async (event) => { 
  try {
    const data = await myStorage.load();
    event.reply('load-inputs-reply', JSON.parse(JSON.stringify(data))); // Ensure data is serializable
  } catch (error) {
    console.error('Failed to send load inputs', error);
    event.reply('load-inputs-reply', {}); // Send empty object on error 
  }
});




// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = () => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 1200,
    height: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  // and load the index.html of the app.
  if (MAIN_WINDOW_VITE_DEV_SERVER_URL) {
    mainWindow.loadURL(MAIN_WINDOW_VITE_DEV_SERVER_URL);
  } else {
    mainWindow.loadFile(path.join(__dirname, `../renderer/${MAIN_WINDOW_VITE_NAME}/index.html`));
  }

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

app.on('ready', createWindow);

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});


// create the search-suppliers function that will be called from the preload.ts file
ipcMain.on('search-suppliers', async (event, supplier, token) => {
  try {
    const suppliers = await searchSuppliers({keyword: supplier}, token);
        event.reply('search-suppliers-reply', suppliers);
    } catch (error) {
        event.reply('search-suppliers-reply', { error: error.message });
    }
});

// src/preload.ts
import { ipcRenderer, contextBridge } from "electron";

let searchSuppliersPromiseResolver: any;

ipcRenderer.on('search-suppliers-reply', (event, res) => {
    if (searchSuppliersPromiseResolver) {
        searchSuppliersPromiseResolver(res);
    }
});




contextBridge.exposeInMainWorld("api", {
    searchSuppliers: (supplier: string, token: string) => new Promise((resolve) => {
        searchSuppliersPromiseResolver = resolve;
        ipcRenderer.send("search-suppliers", supplier, token);
    }),
    saveInputs: (data: any) => ipcRenderer.send('save-inputs', data),
    loadInputs: () => {
        return new Promise((resolve) => {
            ipcRenderer.once('load-inputs-reply', (event, data) => resolve(data));
            ipcRenderer.send('load-inputs');
        });
    },

});

// src/renderer.ts
import './index.css';

const submitButton = document.getElementById('submit') as HTMLButtonElement;
const supplier = document.getElementById('supplier') as HTMLInputElement;
const output = document.getElementById('output') as HTMLDivElement;
const token = document.getElementById('token') as HTMLInputElement;

submitButton.addEventListener('click', async () => {
    // @ts-expect-error it exists
    const res =  await api.searchSuppliers(supplier.value, token.value);
    console.log('res', res)
    
    if(res.statusCode == 0){
        output.innerText = `${res.suppliers.length} suppliers found`;
        console.log('status code from rendere', res.statusCode)
    }
    else{
        output.innerText = 'Error';
    }
});

console.log('ðŸ‘‹ This message is being logged by "renderer.ts", included via Vite');



window.addEventListener('DOMContentLoaded', async () => {
    // @ts-expect-error it exists
    const inputs = await api.loadInputs();
    if (inputs.token) {
        token.value = inputs.token;
    }
    if (inputs.supplier) {
        supplier.value = inputs.supplier; 
    }
}); // what

window.addEventListener('beforeunload', async () => {
    const inputs = {
        token: token.value,
        supplier: supplier.value,
    };
    // @ts-expect-error it exists
    await api.saveInputs(inputs);
});



// src/utilities/storage.ts
import { promises as fs } from 'fs';
import path from 'path';

class Storage {
    private storagePath: string;

    constructor(storageFileName: string) {
        this.storagePath = path.join(__dirname, storageFileName);
        this.initStorage();
    }

    private async initStorage() {
        try {
            await fs.access(this.storagePath);
        } catch (error) {
            if (error.code === 'ENOENT') {
                await fs.writeFile(this.storagePath, '{}', 'utf-8');  // Create a new file if it doesn't exist
            } else {
                throw error;
            } 
        }
    }

    async save(data: object): Promise<void> {
        try {
            const dataString = JSON.stringify(data, null, 2);
            await fs.writeFile(this.storagePath, dataString, 'utf-8');
        } catch (error) {
            console.error('Failed to save data', error);
        }
    }

    async load(): Promise<any> {
        try {
            const dataString = await fs.readFile(this.storagePath, 'utf-8');
            return JSON.parse(dataString);
        } catch (error) {
            console.error('Failed to load data', error);
            return {};  // Return an empty object if there's an error
        }
    }
}

export default Storage;


// tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "commonjs",
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "noImplicitAny": true,
    "sourceMap": true,
    "baseUrl": ".",
    "outDir": "dist",
    "moduleResolution": "node",
    "resolveJsonModule": true
  }
}
